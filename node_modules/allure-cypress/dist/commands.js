// src/commands.ts
var createFinalMesage = () => ({
  startMessage: void 0,
  endMessage: void 0,
  messages: []
});
var { EVENT_TEST_BEGIN, EVENT_TEST_FAIL, EVENT_TEST_PASS } = Mocha.Runner.constants;
var getSuitePath = (test) => {
  const path = [];
  let currentSuite = test.parent;
  while (currentSuite) {
    if (currentSuite.title) {
      path.unshift(currentSuite.title);
    }
    currentSuite = currentSuite.parent;
  }
  return path;
};
var getStepsMessagesPair = (reportMessage) => reportMessage.messages.reduce((acc, message) => {
  if (message.type !== "STEP_STARTED" /* STEP_STARTED */ && message.type !== "STEP_ENDED" /* STEP_ENDED */) {
    return acc;
  }
  if (message.type === "STEP_STARTED" /* STEP_STARTED */) {
    acc.push([message]);
    return acc;
  }
  const unfinishedStepIdx = acc.findLastIndex((step) => step.length === 1);
  if (unfinishedStepIdx === -1) {
    return acc;
  }
  acc[unfinishedStepIdx].push(message);
  return acc;
}, []);
Cypress.mocha.getRunner().on(EVENT_TEST_BEGIN, (test) => {
  const reportMessage = createFinalMesage();
  reportMessage.startMessage = {
    specPath: getSuitePath(test).concat(test.title),
    filename: Cypress.spec.relative,
    start: Date.now()
  };
  Cypress.env("allure", { reportMessage });
}).on(EVENT_TEST_PASS, () => {
  const reportMessage = Cypress.env("allure").reportMessage;
  const grouppedStepsMessage = getStepsMessagesPair(reportMessage);
  const unfinishedStepsMessages = grouppedStepsMessage.filter((step) => step.length === 1);
  unfinishedStepsMessages.forEach(() => {
    reportMessage.messages.push({
      type: "STEP_ENDED" /* STEP_ENDED */,
      payload: {
        stage: "finished" /* FINISHED */,
        status: "passed" /* PASSED */,
        stop: Date.now()
      }
    });
  });
  reportMessage.endMessage = {
    stage: "finished" /* FINISHED */,
    status: "passed" /* PASSED */,
    stop: Date.now()
  };
  Cypress.env("allure", { reportMessage });
}).on(EVENT_TEST_FAIL, (test, err) => {
  const reportMessage = Cypress.env("allure").reportMessage;
  reportMessage.endMessage = {
    stage: "finished" /* FINISHED */,
    status: err.constructor.name === "AssertionError" ? "failed" /* FAILED */ : "broken" /* BROKEN */,
    statusDetails: {
      message: err.message,
      trace: err.stack
    },
    stop: Date.now()
  };
  Cypress.env("allure", { reportMessage });
});
Cypress.Screenshot.defaults({
  onAfterScreenshot: (_, details) => {
    const reportMessage = Cypress.env("allure").reportMessage;
    reportMessage.messages.push({
      type: "SCREENSHOT" /* SCREENSHOT */,
      payload: {
        path: details.path,
        name: details.name || "Screenshot"
      }
    });
    Cypress.env("allure", { reportMessage });
  }
});
Cypress.on("fail", (err) => {
  const reportMessage = Cypress.env("allure").reportMessage;
  const hasSteps = reportMessage.messages.some((message) => message.type === "STEP_STARTED" /* STEP_STARTED */);
  if (!hasSteps) {
    throw err;
  }
  const grouppedStepsMessage = getStepsMessagesPair(reportMessage);
  const unfinishedStepsMessages = grouppedStepsMessage.filter((step) => step.length === 1);
  if (unfinishedStepsMessages.length === 0) {
    throw err;
  }
  const failedStepsStatus = err.constructor.name === "AssertionError" ? "failed" /* FAILED */ : "broken" /* BROKEN */;
  unfinishedStepsMessages.forEach(() => {
    reportMessage.messages.push({
      type: "STEP_ENDED" /* STEP_ENDED */,
      payload: {
        stage: "finished" /* FINISHED */,
        status: failedStepsStatus,
        stop: Date.now(),
        statusDetails: {
          message: err.message,
          trace: err.stack
        }
      }
    });
  });
  Cypress.env("allure", { reportMessage });
  throw err;
});
afterEach(() => {
  const reportMessage = Cypress.env("allure").reportMessage;
  cy.task("allureReportTest", reportMessage, { log: false });
});
//# sourceMappingURL=commands.js.map
